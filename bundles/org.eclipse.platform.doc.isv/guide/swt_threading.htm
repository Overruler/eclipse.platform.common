<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>Threading issues</TITLE>

<link rel="stylesheet" type="text/css" HREF="../book.css">
</HEAD>
<BODY BGCOLOR="#ffffff">
<H2>
Threading issues for clients</H2>
<P >
When working with a widget toolkit, it's important to understand the underlying thread model used for reading and dispatching platform GUI events. The implementation of the UI thread affects the rules that applications must follow when using Java threads in their code.</P>

<H3>
Native event dispatching</H3>
<P >
Underneath any GUI application, regardless of language or UI toolkit, the OS platform is detecting GUI events and placing them in application event queues. Although the mechanics are slightly different on different OS platforms, the basics are similar. As the user clicks the mouse, types characters, or surfaces windows, the OS generates application GUI events, such as mouse clicks, keystrokes, or window paint events. It determines which window (and application) should receive the event and places it in
the application's event queue.</P>
<P >
The underlying structure for any windowed GUI application is an event loop. Applications initialize and then start a loop which simply reads the GUI events from the queue and reacts appropriately. Any work done while handling one of these events must happen quickly in order to keep the GUI system responsive to the user. </P>
<P >
Long operations triggered by UI events should be performed in a separate thread in order to allow the event loop thread to return quickly and fetch the next event from the application's queue. However, access to the widgets and platform API from other threads must be controlled with explicit locking and serialization. An application that fails to follow the rules can cause an OS call to fail, or worse, lock up the entire GUI system.</P>


<H3>
Toolkit UI threads</H3>
<P >
Native GUI programmers using C are quite familiar with the design considerations for working with the platform event loop. However, many higher level widget toolkits in Java often attempt to shield application developers from UI threading issues by hiding the platform event loop. </P>
<P >
A common way to achieve this is to set up a dedicated toolkit UI thread for reading and dispatching from the event loop, and posting the events to an internal queue that is serviced by applications running in separate threads. This allows the toolkit to respond in sufficient time to the operating system, while not placing any restrictions on the application's timing in handling the event. Applications
must still use special locking techniques to access UI code from their application thread, but it is done consistently throughout the code since all application code is running in a non-UI thread.</P>
<P >
Although it sounds tempting to &quot;protect&quot; applications from UI threading issues, it causes many problems in practice. </P>
<P >
It becomes difficult to debug and diagnose problems when the timing of GUI events is dependent on the Java threading implementation and application performance.</P>
<P >
Modern GUI platforms perform many optimizations with the event queue. A common optimization is to collapse multiple paint events in the queue. Every time part of a window must be repainted, the queue can be checked for overlapping or redundant paint events that have not been dispatched yet. These events can be merged into one paint event, causing less flicker and less frequent execution of the application's paint code. This optimization is defeated if the widget toolkit is pulling the events off the queue quickly and posting them to an internal queue.</P>
<P >
Changing the developer's perception of the threading model causes confusion for programmers with experience programming the native GUI system in other languages and toolkits.</P>


<H3>
SWT UI thread</H3>
<P >
SWT follows the threading model supported directly by the platforms. The application program runs the event loop in its main thread and dispatches events directly from this thread. This is the application's &quot;UI thread.&quot; </P>
<i><blockquote>
Note:&nbsp; Technically, the UI thread is the thread that creates the <b>Display</b>. In practice, this is also the thread that runs the event loop and creates the widgets.</blockquote></i>
<P >
Since all event code is triggered from the application's UI thread, application code that handles events can freely access the widgets and
make graphics calls without any special techniques. However, the application is responsible for forking computational threads when performing long operations in response to an event.</P>
<i><blockquote>
Note:&nbsp; SWT will trigger an <b> SWTException</b> for any calls made from a non-UI thread that must be made from the UI thread.</blockquote></i>
<P >
The main thread, including the event loop, for an SWT application looks like this:</P>
<font color='#4444CC'><pre>
   public static void main(String [] args) {
      Display display = new Display();
      Shell shell = new Shell(display);
      shell.open();
      // start the event loop. We stop when the user has done
      // something to dispose our window.
      while (!shell.isDisposed()) {
         if (!display.readAndDispatch())
            display.sleep();
      }
      display.dispose();
   }
</pre></font>
<P >
Once the widgets are created and the shell is opened, the application reads and dispatches events from the OS queue until the shell window is disposed. If there are no events available for us in the queue, we tell the display to sleep to give other applications a chance to run.</P>
<i><blockquote>
Note:&nbsp; The most common threading model for an SWT application is to run a single UI thread and perform long operations in computational threads. However, SWT does not restrict developers to this model. An application could run multiple UI-threads, with a separate event loop in each thread.</blockquote></i>
<P >
SWT provides special access methods for calling widget and graphics code from a background thread.</P>


<H3>
Executing code from a non-UI thread</H3>
<P >
Applications that wish to call UI code from a non-UI thread must provide a <b> Runnable</b> that calls the UI code. The methods
<b> syncExec(Runnable) </b> and <b> asyncExec(Runnable)</b> in the
<b><a href="../reference/api/org/eclipse/swt/widgets/Display.html"> Display</a></b> class are used to execute these runnables
in the UI thread at an appropriate time.</P>
<ul>
  <li><b>syncExec(Runnable)</b> should be used when the application code in the non-UI thread depends on the return value from the UI code or otherwise needs to ensure that the runnable is run to completion before returning to the thread. SWT will block the calling thread until the runnable has been run from the application's UI thread. For example, a background thread that is computing something based on a window's current size would want to synchronously run the code to get the window's size and then continue with its computations.</li>
  <li><b>asyncExec(Runnable)</b> should be used when the application needs to perform some UI operations, but does not depend on the operations being complete before continuing. For example, a background thread that updates a progress indicator or redraws a window could request the update asynchronously and continue with its processing. In this case, there is no guaranteed relationship between the timing of the background thread and the execution of the
    runnable.</li>
</ul>
<P >
The following code snippet demonstrates the pattern for using these methods.</P>
<font color='#4444CC'><pre>
   // do time intensive computations
   ...
   // now update the UI. We don't depend on the result,
   // so use async.
   Display.getCurrent().asyncExec(new Runnable() {
      public void run() {
         myWindow.redraw();
      }
   });
   // now do more computations
   ...
</pre></font>


<H3>
The workbench and threads</H3>
<P >
The threading rules are very clear when you are implementing an SWT application from the ground up, because you control the creation of the event loop and the decision to fork computational threads in your application.</P>
<P >
What are the rules if you are contributing plug-in code to the workbench? Fortunately, there is no threading &quot;magic&quot; hidden in the JFace or workbench code. The rules are straightforward.</P>
<ul>
  <li>Your workbench plug-in code executes in the workbench's UI thread.</li>
  <li>If you receive an event from the workbench, it is always executing in the UI thread of the
    workbench.</li>
  <li>If your plug-in forks a computational thread, it must use the <b><a href="../reference/api/org/eclipse/swt/widgets/Display.html"> Display</a></b>
    <b>asyncExec</b> or <b> syncExec</b> methods when calling any API for the workbench, JFace, or
    SWT.</li>
  <li>Workbench and JFace API calls do not check that the caller is executing in the UI thread. However, SWT triggers an
    <b><a href="../reference/api/org/eclipse/swt/SWTException.html"> SWTException</a></b> for all API calls made from a non-UI thread.</li>
  <li>If your plug-in uses the JFace <a href="../reference/api/org/eclipse/jface/operation/IRunnableContext.html"><b> IRunnableContext</b></a> interface to invoke a progress monitor and run an operation, it supplies an argument to specify whether a computational thread is forked for running the operation.</li>
</ul>
<p><a href="../hglegal.htm"><img border="0" src="../ngibmcpy.gif" width="250" height="12"></a></p>

</BODY>
</HTML>
