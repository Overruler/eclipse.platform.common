<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>
Documents and partitions
</TITLE>

<link rel="stylesheet" type="text/css" HREF="../book.css">
</HEAD>
<BODY BGCOLOR="#ffffff">
<H2>Documents and partitions</H2>
<p>The platform text framework defines a document model for text and provides 
  a viewer that displays text using this model.&nbsp;We will start by looking 
  at the Java editor example and how it uses this model.&nbsp; We will not focus 
  on the basic mechanics of registering an editor extension, since we've already 
  seen this in the section discussing <a href="workbench_basicext_editors.htm"><b>org.eclipse.ui.editors</b></a>.&nbsp; 
  Instead, we'll look at the specifics of how the editor class is implemented 
  in the example.</p>
<h3>Document providers and documents</h3>
<p>In the workbench, an editor is typically opened when the user selects a domain 
  element (such as a file or an element stored inside an archive file) and opens 
  it.&nbsp; When the editor is created, it is associated with an editor input 
  (<a href="../reference/api/org/eclipse/ui/IEditorInput.html"><b>IEditorInput</b></a>), 
  which describes the object being edited.</p>
<p>The Java editor example opens when the user opens a file with the &quot;*.jav&quot; 
  extension.&nbsp; In this case, the input to the editor is an <a href="../reference/api/org/eclipse/ui/IFileEditorInput.html"><b>IFileEditorInput</b></a>.&nbsp; 
  The platform text framework assumes little about the editor input itself.&nbsp; 
  It works with a presentation model, called an <a href="../reference/api/org/eclipse/jface/text/IDocument.html"><b>IDocument</b></a>, 
  for the input, so that it can effectively display and manipulate text.</p>
<p>This means that there must be a way to map from an expected domain model (the 
  editor input) to the presentation model.&nbsp; This mapping is defined in an 
  <a href="../reference/api/org/eclipse/jface/text/IDocument.html"><b>IDocumentProvider</b></a>.&nbsp; 
  Given an editor input, the document provider returns an appropriate <a href="../reference/api/org/eclipse/jface/text/IDocument.html"><b>IDocument</b></a>.</p>
<p>The Java editor example defines a <b>JavaDocumentProvider</b> which returns 
  the appropriate document.&nbsp; How is the relationship between the appropriate 
  document provider and the &quot;*.jav&quot; extension established?&nbsp;It's 
  done in the <b><a href="../reference/extension-points/org_eclipse_ui_editors_documentProviders.html">org.eclipse.ui.editors.documentProviders</a></b> 
  extension.&nbsp; This extension is used to define mappings between file types 
  and document providers.&nbsp; The example defines its document provider as follows:</p>
<font SIZE="2">
<pre><font color="#4444CC">&lt;extension
      point=&quot;org.eclipse.ui.editors.documentProviders&quot;&gt;
   &lt;provider
         extensions=&quot;jav&quot;
         class=&quot;org.eclipse.ui.examples.javaeditor.JavaDocumentProvider&quot;
         id=&quot;org.eclipse.ui.examples.javaeditor.JavaDocumentProvider&quot;&gt;
   &lt;/provider&gt;
&lt;/extension&gt;</font></pre>
</font>
<p>When the user opens a file with the specified extension, the workbench manages 
  the details of creating the document provider instance.&nbsp; The workbench 
  creates a document provider instance only once and shares this instance among 
  different editors.</p>
<p>It is not required that your plug-in use this extension point to register its 
  document provider. Another way to associate a document provider with an editor 
  is to let your plug-in itself manage the document provider.&nbsp; This is usually 
  done in your plug-in class.&nbsp; When an input element is set into your editor, 
  the editor asks its plug-in class for the appropriate document provider.&nbsp; 
  The plug-in can manage the creation and the references to the document provider.&nbsp; 
  This technique may be preferable when there is special initialization or other 
  processing involved with the document provider.&nbsp; See <b>ClassFileEditor</b> 
  in the JDT tooling for an example.&nbsp;</p>
<p>Once the proper document provider is associated with an editor, its main task 
  is to create a document from the editor input and configure an appropriate object 
  for dividing the document up into partitions.&nbsp;&nbsp;</p>
<h4>Partitions</h4>
<p>Let's look at documents and partitions in the <b>JavaDocumentProvider</b>.&nbsp;
When a document is created, an <a href="../reference/api/org/eclipse/jface/text/IDocumentPartitioner.html"><b>IDocumentPartitioner</b></a>
is created and set into the document.&nbsp;&nbsp;</p>
<pre><font color="#4444CC">protected IDocument createDocument(Object element) throws CoreException {
	IDocument document= super.createDocument(element);
	if (document != null) {
		<b>IDocumentPartitioner partitioner= createJavaPartitioner();
		document.setDocumentPartitioner(partitioner);</b>
		partitioner.connect(document);
	}
	return document;
}</font></pre>
<p>The partitioner is responsible for dividing the document into non-overlapping 
  regions called partitions.&nbsp; Partitions (represented at <a href="../reference/api/org/eclipse/jface/text/IDocumentPartitioner.html"><b>ITypedRegion</b></a>) 
  are useful for treating different sections of the document differently with 
  respect to features like syntax highlighting or formatting.</p>
<p> In the case of the Java editor
example, the document is divided into partitions that represent the javadoc
comments, multi line comments, and everything else.&nbsp; Each region is assigned a
content type and its position in the document.&nbsp; Positions are updated as the user edits text.&nbsp;&nbsp;&nbsp;</p>
<h4>Rule based document partitioning</h4>
<p>It is up to each editor to determine the appropriate implementation for a
document partitioner.&nbsp; Support is provided in <b><a href="../reference/api/org/eclipse/jface/text/rules/package-summary.html">org.eclipse.jface.text.rules</a></b>
 for rule-based document scanning.&nbsp; Using a rule-based scanner allows an editor to use
the <a href="../reference/api/org/eclipse/jface/text/rules/DefaultPartitioner.html"><b>DefaultPartitioner</b></a>
provided by the framework.<pre><font color="#4444CC">private IDocumentPartitioner createJavaPartitioner() {
	return new <b>DefaultPartitioner(getJavaPartitionScanner(), TYPES)</b>;
}</font></pre>
<p><a href="../reference/api/org/eclipse/jface/text/rules/RuleBasedPartitionScanner.html"><b>RuleBasedPartitionScanner</b></a><b>
</b>is the superclass for rule based scanners.&nbsp; Subclasses are responsible
for enumerating and implementing the rules that should be used to distinguish
tokens such as line delimiters, white space, and generic
    patterns when scanning a document.&nbsp; The example's <b>JavaPartitionScanner</b>
defines rules for distinguishing single line comments, character constants, javadoc, multi
line comments, and&nbsp;words.&nbsp; This is done in the scanner's constructor:
<pre><font color="#4444CC">public JavaPartitionScanner() {
	super();
	IToken javaDoc= new Token(JAVA_DOC);
	IToken comment= new Token(JAVA_MULTILINE_COMMENT);

	List rules= new ArrayList();
	// Add rule for single line comments.
	rules.add(new EndOfLineRule(&quot;//&quot;, Token.UNDEFINED)); 

	// Add rule for strings and character constants.
	rules.add(new SingleLineRule(&quot;\&quot;&quot;, &quot;\&quot;&quot;, Token.UNDEFINED, '\\')); 
	rules.add(new SingleLineRule(&quot;'&quot;, &quot;'&quot;, Token.UNDEFINED, '\\')); 

	// Add special case word rule.
	rules.add(new WordPredicateRule(comment));

	// Add rules for multi-line comments and javadoc.
	rules.add(new MultiLineRule(&quot;/**&quot;, &quot;*/&quot;, javaDoc, (char) 0, true)); 
	rules.add(new MultiLineRule(&quot;/*&quot;, &quot;*/&quot;, comment, (char) 0, true)); 

	IPredicateRule[] result= new IPredicateRule[rules.size()];
	rules.toArray(result);
	setPredicateRules(result);
}</font></pre>
<p>See the classes in <b><a href="../reference/api/org/eclipse/jface/text/rules/package-summary.html">org.eclipse.jface.text.rules</a></b>
 for more details about defining rules and the types of rules availables.&nbsp;
We'll look at the scanners again when we look at <a href="editors_highlighting.htm">syntax
coloring</a>.</p>

<h4>Annotation models</h4>

<p>Besides providing an appropriate document for an editor input, another important 
  task of a document provider is to supply an appropriate <a href="../reference/api/org/eclipse/jface/text/source/IAnnotationModel.html"><b>IAnnotationModel</b></a> 
  to use with an editor input.&nbsp; This model is used to manage annotations 
  attached to documents.&nbsp; By letting the document provider supply the model, 
  your editor can use a model appropriate for the type of content.&nbsp; We'll 
  look at annotations and how they are presented more closely in the next section.</p>

<p><a href="../hglegal.htm"><img border="0" src="../ngibmcpy.gif" alt="Copyright IBM Corporation and others 2000, 2003." width="324" height="14"></a></p>

</BODY>
</HTML>
