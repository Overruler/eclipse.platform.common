<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>org.eclipse.ui.elementFactories</TITLE>

<link rel="stylesheet" type="text/css" HREF="../book.css">
</HEAD>
<BODY BGCOLOR="#ffffff">


<H3>org.eclipse.ui.elementFactories</H3>
<P >
Element factories are used to recreate workbench model objects from data that was saved during workbench shutdown.</P>
<P >
Before we look closely at the element factory extension, we need to review a general technique used throughout the platform to add plug-in specific behavior to common platform model objects.</P>

<H4>
<a name="workbench_advext_adaptables">
IAdaptables and workbench adapters</a></H4>
<P >
When browsing the various workbench classes, you will notice that many of the workbench interfaces extend the
<b><a href="../reference/api/org/eclipse/core/runtime/IAdaptable.html"> IAdaptable</a></b> interface.</P>
<P >
Plug-ins use adapters to add specific behavior to pre-existing types in the system. For example, the workbench may want to add behavior to resources so that they answer a label and image to represent themselves in the UI. We know that it's not good design to add UI specific behavior to low level objects, so how can we add this behavior to the resource types?</P>
<P >
The platform defines a technique for dynamically querying an object for its implementation of a particular interface. Plug-ins can register adapters which add behavior to pre-existing types. This way, application code can later query for a particular adapter for an object when using it in a specific context. If there is one registered for it, they can obtain the adapter and use the new behaviors defined in the adapter.</P>
<P >
By providing a facility to dynamically query an adapter for an object, we can also improve the flexibility of the system as it evolves. New adapters can be registered for platform types by new plug-ins without having to change the definitions of the original types. The pattern is to ask an object for a particular adapter. </P>
<font color='#4444CC'><pre>
   //given an object o, we want to do &quot;workbench&quot; things with it.
   if (!(o instanceof IAdaptable)) {
      return null;
   }
   IWorkbenchAdapter adapter = (IWorkbenchAdapter)o.getAdapter(IWorkbenchAdapter.class);
   if (adapter == null)
      return null;
   // now I can treat o as an IWorkbenchAdapter
   ...
</pre></font>
<P >
If there is no adapter registered for the object in hand, null will be returned as the adapter. Clients must be prepared to handle this case. This allows clients to gracefully handle the case where an expected adapter has not been registered.</P>
<P >
The workbench uses adapters to obtain UI information from the base platform types, such as
<b><a href="../reference/api/org/eclipse/core/resources/IResource.html">IResource</a></b>. This shields the base types from particular knowledge of the UI and allows the workbench to evolve its interfaces without changing the definitions of the base. </P>
<P >
Without adapters, any class that might be passed around in the workbench API would have to implement the UI interfaces. This clutters the class definitions and introduces tight coupling. It introduces circular dependencies between the core and UI classes. With adapters, each class implements
<b><a href="../reference/api/org/eclipse/core/runtime/IAdaptable.html"> IAdaptable</a></b>
and uses the adapter registry to allow plug-ins to extend the behavior of the base types.</P>
<P >
Throughout the workbench code, you'll see cases where a type is queried for an adapter. This is all happening in order to obtain an object that knows how to answer UI oriented information about a platform core type.</P>


<H4>
Element factories</H4>
<P >
When the workbench is shut down by the user, it must save the current state of the
<b><a href="../reference/api/org/eclipse/core/runtime/IAdaptable.html"> IAdaptable</a></b>
objects shown in the workbench. This is done by saving primitive data parameters of the object in a special format, an
<a href="../reference/api/org/eclipse/ui/IMemento.html"><b>IMemento</b></a>, that is easily saved in the file system. The id of a factory that can recreate the object from an
<a href="../reference/api/org/eclipse/ui/IMemento.html"><b>IMemento</b></a>
is also stored.</P>
<P >
When the platform is restarted, the workbench finds the element factory associated with the factory id known in the memento. It finds the factory by checking the plug-in registry for contributions to the
<a href="../reference/extension-points/org_eclipse_ui_elementFactories.html"><b> org.eclipse.ui.elementFactories</b></a> extension.</P>
<P >
The markup is pretty simple. We just have to specify the id of the factory and the corresponding class that implements the factory.</P>
<P >
The following code snippet is from the workbench <b>plugin.xml</b>.</P>
<font color='#4444CC'><pre>
   &lt;extension
      point = &quot;org.eclipse.ui.elementFactories&quot;&gt;
      &lt;factory
         id =&quot;org.eclipse.ui.internal.model.ResourceFactory&quot;
         class=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot;&gt;
      &lt;/factory&gt;
      &lt;factory
         id =&quot;org.eclipse.ui.internal.model.WorkspaceFactory&quot;
         class=&quot;org.eclipse.ui.internal.model.WorkspaceFactory&quot;&gt;
      &lt;/factory&gt;
      &lt;factory
         id =&quot;org.eclipse.ui.part.FileEditorInputFactory&quot;
         class=&quot;org.eclipse.ui.part.FileEditorInputFactory&quot;&gt;
      &lt;/factory&gt;
      &lt;factory
         id =&quot;org.eclipse.ui.internal.dialogs.WelcomeEditorInputFactory&quot;
         class=&quot;org.eclipse.ui.internal.dialogs.WelcomeEditorInputFactory&quot;&gt;
      &lt;/factory&gt;
   &lt;/extension&gt;
</pre></font>



<p><a href="../hglegal.htm"><img border="0" src="../ngibmcpy.gif" width="250" height="12"></a></p>

</BODY>
</HTML>
