<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>Concurrency infrastructure</TITLE>

<link rel="stylesheet" type="text/css" HREF="../book.css">
</HEAD>
<BODY BGCOLOR="#ffffff">
<H2>
Concurrency infrastructure</H2>
<p>
The <b><a href="../reference/api/org/eclipse/core/runtime/jobs/package-summary.html"> org.eclipse.core.runtime.jobs</a></b> 
package provides infrastructure for scheduling, executing, and managing concurrently running operations. The basic
unit of concurrently running work is represented by the <tt>Job</tt> class. When
a job is scheduled, it is added to a job queue managed by the platform.  A background
thread will then remove jobs from the queue and invoke the <tt>Job.run</tt> method.
Let's look at a trivial example of a job:
<font color='#4444CC'><pre>
   class TrivialJob extends Job {
      public TrivialJob() {
         super("Trivial Job");
      }
      public IStatus run(IProgressMonitor monitor) {
         System.out.println("This is a job");
         return Status.OK_STATUS;
      }
   }
</pre></font>
This job can be created and scheduled to execute as follows:
<font color='#4444CC'><pre>
   TrivialJob job = new TrivialJob();
   System.out.println("About to schedule a job");
   job.schedule();
   System.out.println("Finished scheduling a job");
</pre></font>
The output of this program is timing dependent.  That is, there is no way
to be sure when the job's <tt>run</tt> method will execute in relation
to the thread that invoked <tt>schedule</tt>.  In this case, the output
will either be:
<font color='#4444CC'><pre>
   About to schedule a job
   This is a job
   Finished scheduling a job
</pre></font>
Or:
<font color='#4444CC'><pre>
   About to schedule a job
   Finished scheduling a job
   This is a job
</pre></font>
</p>
<p>
If you want to be certain that a job has completed before continuing, you can use
the <tt>Job.join</tt> method.  As with <tt>java.lang.Thread.join()</tt>, this 
method will block the caller until the job has completed, or until the calling thread
is interrupted.  Let's rewrite our snippet from above in a more deterministic manner:
<font color='#4444CC'><pre>
   TrivialJob job = new TrivialJob();
   System.out.println("About to schedule a job");
   job.schedule();
   job.join();
   if (job.getResult().isOk())
      System.out.println("Job completed with success");
   else
      System.out.println("Job did not complete successfully");
</pre></font>
Assuming the <tt>join</tt> call is not interrupted, this method is guaranteed to
return the following result:
<font color='#4444CC'><pre>
   About to schedule a job
   This is a job
   Job completed with success
</pre></font>
</p>
<p>
Of course, it is generally not useful to join a job immediately after scheduling it,
since you obtain no concurrency by doing so. In this case you might as well
call <tt>Job.run</tt> directly in the calling thread.  However, we will see some
examples later on where <tt>join</tt> is more useful.
</p>
<p>
You'll notice this new example also makes use of the job <i>result</i>.  The result
is the <tt>IStatus</tt> object that is returned from the Job's <tt>run</tt> method.
By creating your own subclass of <tt>Status</tt>, you can use the result to pass
arbitrary objects back from the job's run method. The result can also be used to
indicate failure (by returning an <tt>IStatus</tt> with severity <tt>IStatus.ERROR</tt>),
or cancelation (<tt>IStatus.CANCEL</tt>).
</p>
<h3>Common job operations</h3>
<p>
We've seen the <tt>schedule</tt> and <tt>join</tt> methods, but jobs have a 
number of other interesting methods to allow you to interact with them. If you
schedule a job but then decide it is no longer needed, the job can be stopped using
the <tt>cancel</tt> method.  If the job has not yet started running when <tt>cancel</tt>
is called, the job is immediately discarded and will not run.  If, on the other hand, the job 
has already started running, it is up to the job whether it wants to respond to the cancelation.
This is a situation where joining the job comes in handy.  Here is a common idiom for
canceling a job, and ensuring that the job has finished before proceeding:
<font color='#4444CC'><pre>
   if (!job.cancel())
      job.join();
</pre></font>
If the cancelation did not take effect immediately, then <tt>cancel</tt> will return 
<tt>false</tt>, and the <tt>join</tt> is needed to wait for the job to respond to the
cancelation request.
</p>
<p>
Slightly less drastic than cancelation is the <tt>Job.sleep</tt> method.  Again,
if the job has not yet started running, the <tt>sleep</tt> method will cause the
job to be put on hold indefinitely.  The job will still be remembered by the platform,
and a call to <tt>Job.wakeUp</tt> will cause the job to be added to the wait
queue where it will eventually be executed. 
</p>
<h3>Job families</h3>
<p>
Sometimes you may want to query or modify a whole group of related jobs. This
can be accomplished using <i>job families</i>.  A job declares that it belongs to
a certain family by overriding the <tt>belongsTo</tt> method:
<font color='#4444CC'><pre>
   public static final String MY_FAMILY = "myJobFamily";
   ...
   class FamilyJob extends Job {
      ...
      public boolean belongsTo(Object family) {
         return family == MY_FAMILY;
      }
   }
</pre></font>
You can now cancel, join, sleep, or find all jobs in that family by using methods on
<tt>IJobManager</tt>:
<font color='#4444CC'><pre>
   IJobManager jobMan = Platform.getJobManager();
   jobMan.cancel(MY_FAMILY);
   jobMan.join(MY_FAMILY, null);
</pre></font>
Note that since job families are arbitrary objects, you can store interesting
state in the job family itself, and jobs can dynamically decide what families
they belong to as needed. Just be sure to use a family object that is 
fairly unique, to avoid accidental interaction with the families created by
other plug-ins. Families are also a convenient way of locating particular
groups of jobs.  The method <tt>IJobManager.find(Object family)</tt> can
be used to locate instances of all running, waiting, and sleeping jobs at any
given time.
</p>

<p><a href="../hglegal.htm"><img border="0" src="../ngibmcpy.gif" alt="Copyright IBM Corporation and others 2000, 2003." border="0" width="324" height="14"></a></p>
</BODY>
</HTML>