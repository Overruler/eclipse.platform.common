<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta http-equiv="Content-Style-Type" content="text/css">
   <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
   <title>Eclipse Platform: Installation and Update</title>
<link REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
</head>
<body>

<h1>
Eclipse Platform<br>
Installation and Update</h1>
<font size=-1>Revision Date: 09/15/01 08:45 PM - Version: 0.14</font>
<br><a href="hglegal.htm"><img SRC="ngibmcpy.gif" BORDER=0 height=12 width=195></a>
<br>&nbsp;
<table BORDER COLS=1 WIDTH="100%" >
<tr>
<td><b><i>Note:</i> The update manager is still under development and can
be expected to change significantly before reaching stability. It is being
made available at this stage to solicit feedback from early adopters, on
the understanding that the details of the installation structure will change
in breaking ways.</b></td>
</tr>
</table>

<p><a href="#Introduction">Introduction</a>
<br><a href="#Scenarios">Scenarios</a>
<br><a href="#Packaging_Conventions">Packaging Conventions</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Concepts">Concepts</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Component_Archive">Component
Archive</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Configuration_Archive">Configuration
Archive</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Translating_Packaging_Information">Translating
Packaging Information</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Security_Considerations">Security
Considerations</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Packaging_NL">Packaging
NL</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Packaging_Target_Specific_Support">Packaging
Target-Specific Support</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Packaging_Support_Deliverables">
Packaging Support Deliverables</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#attrib"> Packaging Attribution
Information</a>
<br><a href="#Installation_Structure">Installation Structure</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Full_vs_Reference_Install">Full
vs. Reference Install</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#File_System_Mapping_Full_Install">File
System Mapping: Full Install</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Workspace_Files">Workspace
Files</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#File_System_Mapping_Reference_Install">File
System Mapping: Reference Install</a>
<br><a href="#Launching_Eclipse">Launching Eclipse</a>
<br><a href="#Update_Considerations">Update Considerations</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Updating_Non_Platform_Components">Updating
Non-Platform Components</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Updating_the_Platform">Updating
the Platform</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Updating_JRE">Updating
JRE</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Updating_Launch_Support">Updating
Launch Support</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Recovering_from_Update_Failures">Recovering
from Update Failures</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Recovering_from_Bad_Updates">Recovering
From Bad Updates</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Installation_Cleanup">Installation
Cleanup</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Unmanaged_Eclipse_Function">Unmanaged
Eclipse Function</a>
<br><a href="#Installation_Considerations">Installation Considerations</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#New_Installation">New
Installation</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Merged_Installation">Merged
Installation</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Platform_Specific_Registration">Platform-Specific
Registration</a>
<br><a href="#Development_Considerations">Development Considerations</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Installation_Location_Independence">Installation
Location Independence</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Native_Executables">Native
Executables</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Concurrent_Plug_In_Version_Support">Concurrent
Plug-in Version Support</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Version_Migration">Version
Migration</a>
<h2>
<a NAME="Introduction"></a>Introduction</h2>
This document outlines the support for managing the delivery of function
within the Eclipse platform.
<h2>
<a NAME="Scenarios"></a>Scenarios</h2>
The Eclipse platform contains a built-in update manager that is used as
part of installation of Eclipse-based function, as well as for delivery
of service updates and function upgrades. The following scenarios are supported
in the initial version of Eclipse:
<ul>
<li>
&nbsp;traditional new product installation</li>

<br>In this scenario a product built using Eclipse is packaged using platform-specific
installer technology, such as Windows MSI installer, RPM, InstallShield,
or any simple archival mechanism (eg. a .zip file). The product packager
follows the Eclipse file layout convention described later (see "File System
Mapping: Full Install"). During install, new product installation tree
is created in the local file system, and the installer copies the packaged
files. This includes a copy of the Eclipse platform, optionally the Java
jre environment and any product plug-ins that will execute on top of the
Eclipse platform.
<li>
&nbsp;traditional merged installation</li>

<br>In this scenario a product built using Eclipse is packaged using platform-specific
installer technology, such as Windows MSI installer, RPM, InstallShield,
or any simple archival mechanism (eg. a .zip file). The product packager
follows the Eclipse file layout convention described later (see "File System
Mapping: Full Install"). During install, the installer detects that the
user already has an Eclipse-based installation on his system (see section
"Platform-Specific Registration"). The installer offers the user the option
of merging the new function into the existing installation (the other choice
is installing the new function as a new installation (prior scenario)).
In the case of a simple archive, the user performing the installation manually
selects the existing install directory (no assistance provided by the archival
utility, such as zip).
<li>
&nbsp;updating components</li>

<br>The standard Eclipse workbench contains a dialog that allows previously
installed components to be update over the network. Metadata packaged with
each component allows the wizard to determine the update server location.
The Eclipse platform must be restarted for the update to become activated.
<li>
&nbsp;adding new components</li>

<br>The standard Eclipse workbench contains a dialog that allows new components
to be "discovered" and added over the network. The Eclipse platform must
be restarted for the newly added components to become activated.</ul>

<h2>
<a NAME="Packaging_Conventions"></a>Packaging Conventions</h2>

<h3>
<a NAME="Concepts"></a>Concepts</h3>
<b>Plug-in</b>
<br>Eclipse developers build plug-ins. Plug-ins are the base units of execution
recognized by the Eclipse runtime environment. In general, plug-ins are
not exposed to users that select function during installation or update.
The reason is that plug-in boundaries are established by developers for
development reasons (like function reuse) and present the wrong level of
granularity in terms of what the user sees as the unit of function.
<p>While plug-ins are being developed (ie. are frequently being changed),
their internal file structure will reflect what is convenient to the developer.
This will generally depend on the particular development tool being used.
Typically, however, the developer will likely setup the plug-in to execute
from a directory tree containing exposed .class files, rather than executing
from a .jar (requires an extra step to create the .jar and we all know
developers hate extra steps). Also, at this stage the developer does not
pay particular attention to plug-in versioning information, because the
plug-in is continually changing.
<p>However, when the plug-in is ready to be packaged, it needs to be converted
to a form suitable for packaging and installation. Typically it means creation
of the runtime .jar(s) and removing any development-time files (source,
exposed .class files, etc). It also means updating the plugin.xml manifest
with the formal plug-in version and reflecting the version in the plug-in
directory name (see "Concurrent Plug-In Version Support" for details).
<p><b>Plug-in Fragment</b>
<br>Plug-in Fragments (or simply Fragments) allow independent packaging
of certain aspects of the base plug-in. This includes (but may not be limited
to) translated resources for the plug-in, OS-specific or windowing-system-specific
code, or plug-in content targeted at alternate users (eg. SDK developer
information supplied with a plug-in). At runtime, fragments are logically
merged into the base plug-in. From a packaging point of view, they are
allowed to be physically packaged with the base plug-in, or packaged and
serviced separately. This, for example, allows creation of a "language
pack", or a particular "os pack" independent from the base function distribution.
<p><b>Component</b>
<br>A component is typically a group of plug-ins and/or plug-in fragments
that deliver some user function. Components can be exposed to users as
part of the packaging and installation process, because they represent
a unit of function selection. Components also represent a unit of installation
(all contained files are installed together into one install tree). Components
carry a version identifier.
<p>Components are packaged as a Java .jar, containing the required plug-ins,
plug-in fragments and a component installation manifest (an xml file).
The component .jar(s) can be placed on a update server for download and
installation by the Eclipse update manager, or they can be used as the
input into a formal packaging process using one of the "traditional" installer
technologies. The format of the component jar and its installation manifest
are described later.
<p><b>Configuration</b>
<br>A configuration is a versioned grouping mechanism for a set of versioned
components. It can, for example, be used to specify which configuration
of components was built and tested together as a particular version of
a product.
<p>Configurations are packaged as a Java .jar, containing the configuration
installation manifest (an xml file). The manifest contains references to
components that make up the configuration, together with installation and
version update constraints. Note, the configuration .jar does not actually
contain the component files (just references).
<p>The configuration .jar(s) can be placed on a update server for download
and installation by the Eclipse update manager, or they can be used as
the input into a formal packaging process using one of the "traditional"
installer technologies. The format of the configuration jar and its installation
manifest are described later.
<p>The current Eclipse implementation does not allow configurations to
be nested.
<h3>
<a NAME="Component_Archive"></a>Component Archive (.jar)</h3>
Components are identified using a structured identifier based on the provider
internet domain name. For example, organization eclipse.org may produce
component org.eclipse.platform. The character set used for component identifiers
is as specified for plug-in identifiers (see reference information describing
the plug-in manifest).
<p>The component identifier is used as part of the name for the component
.jar, as well as the component directory name within the .jar structure
(and consequently the installation tree). Since more than one version of
a given component can be concurrently installed, the name of the component
.jar as well as its directory name also encode the version identifier.
The version identifier follows the format defined by Eclipse for plug-in
version identifiers (see javadoc for PluginVersionIdentifier class). It
is a 3-part numeric identifier consisting of major, minor and service components
(eg. 2.4.11)
<p>The name is of the form
<br><tt>&lt;componentId>_&lt;version></tt>
<p>For example,
<br><tt>org.eclipse.platform_1.0.3.jar</tt>
<br><tt>com.ibm.tools.jspeditor_3.1.0\install.xml</tt>
<p>The component jar has the following internal path structure:
<p><tt>install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; components/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;componentId>_&lt;version>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(other optional files)see "Translating Packaging Information"</tt>
<br><tt>&nbsp;&nbsp;&nbsp; plugins/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;pluginId>_&lt;pluginVersion>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
plugin.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(other plug-in files)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fragments/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fragmentId>_&lt;fragmentVersion>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fragment.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(other fragment files, may also include plugin.xml)</tt>
<p>The .jar contains exactly one install/components/ path with exactly
one install.xml file. It contains zero-or more plug-ins in their relative
directories (with version qualifier). It contains zero-or more plug-in
fragments in their relative directories (with version qualifier). It also
contains the meta-inf/ directory produced by the Java jar utilities.
<p>The component install.xml format is defined by the following dtd:
<p><tt>&lt;?xml encoding="US-ASCII"?></tt>
<p><tt>&lt;!ELEMENT component (description?, url?, plugin*, fragment*)></tt>
<br><tt>&lt;!ATTLIST component</tt>
<br><tt>&nbsp;&nbsp;&nbsp; label CDATA #IMPLIED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; id CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; version CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; provider-name CDATA #IMPLIED</tt>
<br><tt>></tt>
<p><tt>&lt;!ELEMENT description (#PCDATA)></tt>
<p><tt>&lt;!ELEMENT url (update*, discovery*)></tt>
<p><tt>&lt;!ELEMENT update EMPTY></tt>
<br><tt>&lt;!ATTLIST update</tt>
<br><tt>&nbsp;&nbsp;&nbsp; url CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; label CDATA #IMPLIED</tt>
<br><tt>></tt>
<p><tt>&lt;!ELEMENT discovery EMPTY></tt>
<br><tt>&lt;!ATTLIST discovery</tt>
<br><tt>&nbsp;&nbsp;&nbsp; url CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; label CDATA #IMPLIED</tt>
<br><tt>></tt>
<p><tt>&lt;!ELEMENT plugin EMPTY></tt>
<br><tt>&lt;!ATTLIST plugin</tt>
<br><tt>&nbsp;&nbsp;&nbsp; label CDATA #IMPLIED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; id CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; version CDATA #REQUIRED</tt>
<br><tt>></tt>
<p><tt>&lt;!ELEMENT fragment EMPTY></tt>
<br><tt>&lt;!ATTLIST fragment</tt>
<br><tt>&nbsp;&nbsp;&nbsp; label CDATA #IMPLIED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; id CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; version CDATA #REQUIRED</tt>
<br><tt>></tt>
<p>The element and attribute definitions are as follows:
<ul>
<li>
&lt;component> - defines the component</li>

<ul>
<li>
label - optional displayable label (name)</li>

<li>
id - required component identifier (eg. org.eclipse.platform)</li>

<li>
version - required component version (eg. 1.0.3)</li>

<li>
provider-name - optional display label identifying the organization providing
this component</li>
</ul>

<li>
&lt;description> - brief component description</li>

<li>
&lt;url> - optional URL specifying site(s) contain component updates, or
new components</li>

<ul>
<li>
&lt;update> - URL to go to for updates to this component</li>

<ul>
<li>
url - actual URL</li>

<li>
label - displayable label (name) for the referenced site</li>
</ul>

<li>
&lt;discovery> - URL to go to for new components or configurations. In
general, a provider can use this element to reference its own site(s),
or site(s) of partners that offer complementary components or configurations.
Eclipse uses this element simply as a way to distribute new site URLs to
the clients</li>

<ul>
<li>
url - actual URL</li>

<li>
label - displayable label (name) for the referenced site</li>
</ul>
</ul>

<li>
&lt;plugin> - identifies contained plug-in</li>

<ul>
<li>
label - optional displayable label (name) of the included plug-in</li>

<li>
id - required plug-in identifier</li>

<li>
version - required plug-in version. The version identifier follows the
format defined by Eclipse for plug-in version identifiers (see javadoc
for PluginVersionIdentifier class).</li>
</ul>

<li>
&lt;fragment> - identifies contained plug-in fragment</li>

<ul>
<li>
label - optional displayable label (name) of the included plug-in fragment</li>

<li>
id - required plug-in fragment identifier. Note, that the base plug-in
identifier is part of the fragment identifier (eg. org.eclipse.platform_de_DE
as the identifier for the German platform translation packaged as a fragment)</li>

<li>
version - required plug-in fragment version. The version identifier follows
the format defined by Eclipse for plug-in version identifiers (see javadoc
for PluginVersionIdentifier class).</li>
</ul>
</ul>

<h3>
<a NAME="Configuration_Archive"></a>Configuration Archive (.jar)</h3>
Configurations are identified using a structured identifier based on the
provider internet domain name. For example, organization eclipse.org may
produce configuration org.eclipse.sdk. The character set used for configuration
identifiers is as specified for plug-in identifiers (see reference information
describing the plug-in manifest).
<p>The configuration identifier is used as part of the name for the cofiguration
.jar, as well as the configuration directory name within the .jar structure
(and consequently the installation tree). Since more than one version of
a given configuration can be concurrently installed, the name of the configuration
.jar as well as its directory name also encode the version identifier.
The version identifier follows the format defined by Eclipse for plug-in
version identifiers (see javadoc for PluginVersionIdentifier class). It
is a 3-part numeric identifier consisting of major, minor and service components
(eg. 2.4.11)
<p>The name is of the form
<br><tt>&lt;configurationId>_&lt;version></tt>
<p>For example,
<br><tt>org.eclipse.sdk_1.1.5.jar</tt>
<br><tt>com.ibm.wsa_1.0.1\install.xml</tt>
<p>The configuration jar has the following internal path structure:
<p><tt>install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; configurations/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;configurationId>_&lt;version>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(other optional files)see "Translating Packaging Information"</tt>
<p>The .jar contains exactly one install/configurations/ path with exactly
one install.xml file. It also contains the meta-inf/ directory produced
by the Java jar utilities.
<p>The configuration install.xml format is defined by the following dtd:
<p><tt>&lt;?xml encoding="US-ASCII"?></tt>
<p><tt>&lt;!ELEMENT configuration (description?, url?, component*)></tt>
<br><tt>&lt;!ATTLIST configuration</tt>
<br><tt>&nbsp;&nbsp;&nbsp; label CDATA #IMPLIED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; id CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; version CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; provider-name CDATA #IMPLIED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; application CDATA #IMPLIED</tt>
<br><tt>></tt>
<p><tt>&lt;!ELEMENT description (#PCDATA)></tt>
<p><tt>&lt;!ELEMENT url (update*, discovery*)></tt>
<p><tt>&lt;!ELEMENT update EMPTY></tt>
<br><tt>&lt;!ATTLIST update</tt>
<br><tt>&nbsp;&nbsp;&nbsp; url CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; label CDATA #IMPLIED</tt>
<br><tt>></tt>
<p><tt>&lt;!ELEMENT discovery EMPTY></tt>
<br><tt>&lt;!ATTLIST discovery</tt>
<br><tt>&nbsp;&nbsp;&nbsp; url CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; label CDATA #IMPLIED</tt>
<br><tt>></tt>
<p><tt>&lt;!ELEMENT component EMPTY></tt>
<br><tt>&lt;!ATTLIST component</tt>
<br><tt>&nbsp;&nbsp;&nbsp; label CDATA #IMPLIED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; id CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; version CDATA #REQUIRED</tt>
<br><tt>&nbsp;&nbsp;&nbsp; allowUpgrade (true | false) "false"</tt>
<br><tt>&nbsp;&nbsp;&nbsp; optional (true | false) "false"</tt>
<br><tt>></tt>
<p>The element and attribute definitions are as follows:
<ul>
<li>
&lt;configuration> - defines the configuration</li>

<ul>
<li>
label - optional displayable label (name)</li>

<li>
id - required configuration identifier (eg. org.eclipse.sdk)</li>

<li>
version - required configuration version (eg. 1.0.3)</li>

<li>
provider-name - optional display label identifying the organization providing
this configuration</li>

<li>
application - optional, an identifier of an extension registered into the
eclipse application extension point. If not specified, the identifier defaults
to the standard Eclipse workbench application. This is the application
that will be launched if the containing configuration represents the "main"
application that was installed</li>
</ul>

<li>
&lt;description> - brief configuration description</li>

<li>
&lt;url> - optional URL specifying site(s) contain configuration updates</li>

<ul>
<li>
&lt;update> - URL to go to for updates to this configuration</li>

<ul>
<li>
url - actual URL</li>

<li>
label - displayable label (name) for the referenced site</li>
</ul>

<li>
&lt;discovery> - URL to go to for new components or configurations. In
general, a provider can use this element to reference its own site(s),
or site(s) of partners that offer complementary components or configurations.
Eclipse uses this element simply as a way to distribute new site URLs to
the clients</li>

<ul>
<li>
url - actual URL</li>

<li>
label - displayable label (name) for the referenced site</li>
</ul>
</ul>

<li>
&lt;component> - identifies the configured component</li>

<ul>
<li>
label - optional displayable label (name) of the configured component</li>

<li>
id - required component identifier</li>

<li>
version - required component version</li>

<li>
allowUpgrade - optional, default is "false". Indicates to the update manager
whether the configuration allow the component to be upgraded to a new minor
version of the same component (true) or only allows service updates (false).
A configuration never allows a component to be upgraded to a new major
version. Such a change would require the configuration to be first updated.</li>

<li>
optional - optional, default is "false". Indicates to the update manager
whether this component must always be installed as part of this configuration
(false) or can be excluded (deselected) from the installation (true)</li>
</ul>
</ul>
The current Eclipse implementation does not allow configurations to be
nested, or more complex
<br>component rules to be specified.
<h3>
<a NAME="Translating_Packaging_Information"></a>Translating Packaging Information</h3>
<b>Note:</b> This section describes the conventions used for translating
the information contained within the installation manifest. It allows for
the update client to select the correctly localized strings from the update
server. This section specifically does not describe localization of individual
plug-ins.
<p>Several of the attributes within the installation manifests are strings
intended for display through user interfaces. To facilitate translation,
these attribute values use the convention defined for translatable attributes
of plugin.xml. Strings beginning with % up to the first space are treated
as resource identifier keys (without the %) and looked up in a properties
file. For example
<p><tt>label="%cfg Eclipse SDK for Linux"</tt>
<p>results in a resource lookup in the correct property file with key "cfg".
If no property files are supplied, or the key is not found the default
string value (following the %key) is used.
<p>The property files are named as install_&lt;locale>.properties using
the Java resource bundle naming conventions. Within the component and configuration
.jar they are placed in the same directory as their corresponding install.xml
file.
<p>When accessing the resource bundles the code can either select the appropriate
NL-variant of the manifest (by implementing a lookup algorithm) and then
create a bundle using
<p><tt>ResourceBundle b;</tt>
<br><tt>b = new PropertyResourceBundle(properties.openStream());</tt>
<p>Alternatively, the code can use the base Java support for locating the
correct NL-variant of the manifest as follows:
<p><tt>ResourceBundle b;</tt>
<br><tt>ClassLoader l;</tt>
<br><tt>l = new URLClassLoader(new URL[] {&lt;targetDirectoryURL>}, null);</tt>
<br><tt>b = ResourceBundle.getBundle("install",Locale.getDefault(),l);</tt>
<p>The resulting resource bundle can be used in <tt>IPluginDescriptor.getResourceString(String,ResourceBundle)</tt>
to actually return the correct translated string for the manifest attribute.
<p>Note, that in general the installation manifest should specify UTF-8
encoding. For example
<p><tt>&lt;?xml version="1.0" encoding="UTF-8"?></tt>
<h3>
<a NAME="Security_Considerations"></a>Security Considerations</h3>
The component and configuration .jar(s) can be signed using standard Java
security utilities (eg. jarsigner). At runtime, the update manager will
check to see if the requested jar is supplied by a trusted provider, and
that the jar content has not been modifies since it was signed. The user
has the option of accepting untrusted jar(s). Jars that have been modified
after being signed are rejected by the Eclipse runtime.
<h3>
<a NAME="Packaging_NL"></a>Packaging NL</h3>
NL files are packaged in separate subdirectories for each supported locale.
The subdirectories can be defined within the actual plug-in directory (ie.
defined "inline" with the plug-in), or they can be packaged in separate
plug-in fragments. In either case, the Eclipse runtime provides services
to "knit" the base plug-in directory and the appropriate locale files into
a single logical access structure (however they are physically packaged).
This is accomplished&nbsp; by the plug-in, or the fragments supplying a
<tt>&lt;runtime></tt>
entry containing
<p><tt>&nbsp;&nbsp;&nbsp; &lt;library name="$nl$/"/></tt>
<p>Packaging NL files as plug-in fragments results in a slightly more complex
installation structure. The main benefit is the fact that the NL content
can be added to the base after the fact (ie. does not have to ship at the
same time). It also allows the fragments to evolve independent of the base
(with respect to service updates).
<p>The following are the resulting alternative installation structures
for packaging NL.
<p><b>Packaging NL "inline" with plug-in</b>
<p><tt>install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; plugins/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;pluginId>_&lt;version>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("plug-in" files)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nl/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;locale>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(NL files)</tt>
<p>For example:
<p><tt>install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; plugins/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my.funky.plugin_1.0.1/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
plugin.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my.jar ... contains classes and default resources</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nl/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
de_DE/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my.jar ... contains the translated delta</tt>
<p><b>Packaging NL as a plug-in fragment</b>
<p><tt>install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fragments/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fragmentId>_&lt;version>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fragment.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nl/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;locale>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(NL files)</tt>
<p>For example:
<p><tt>install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fragments/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my.funky.plugin_german_1.0.1/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fragment.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nl/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
de_DE/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my.jar ... contains the translated delta</tt>
<p>The locale directory names follow the standard Java locale naming conventions.
<p>Note, that in general the base plug-in content should always include
the default NL resources so that the function behaves in a reasonable way
in the absence of the proper locale tree (ie. better to show default string
rather than resource ids in UI).
<p>The runtime mechanisms, fragment.xml format and APIs for managing NL
directories and fragments are described elsewhere in Eclipse platform documentation.
<h3>
<a NAME="Packaging_Target_Specific_Support"></a>Packaging Target-Specific
Support</h3>
OS and windowing-system-specific files are packaged in separate subdirectories
for each supported target. The subdirectories can be defined within the
actual plug-in directory (ie. defined "inline" with the plug-in), or they
can be packaged in separate plug-in fragments. In either case, the Eclipse
runtime provides services to "knit" the base plug-in directory and the
appropriate target-specific files into a single logical access structure
(however they are physically packaged). This is accomplished&nbsp; by the
plug-in, or the fragments supplying <tt>&lt;runtime></tt> entries containing
<p><tt>&nbsp;&nbsp;&nbsp; &lt;library name="$os$/"/></tt>
<br><tt>&nbsp;&nbsp;&nbsp; &lt;library name="$ws$/"/></tt>
<p>Packaging target-specific files as plug-in fragments results in a slightly
more complex installation structure. The main benefit is the fact that
the target-specific support can be added to the base after the fact (ie.
does not have to ship at the same time). It also allows the fragments to
evolve independent of the base (with respect to service updates).
<p>The following are the resulting alternative installation structures
for packaging target-specific files.
<p><b>Packaging target-specific support "inline" with plug-in</b>
<p><tt>install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; plugins/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;pluginId>_&lt;version>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("plug-in" files)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
os/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;os-name>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(OS-specific files)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ws/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;windowing-system-name>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(WS-specific files)</tt>
<p>For example:
<p><tt>install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; plugins/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my.funky.plugin_1.0.1/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
plugin.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my.jar</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
os/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
solaris/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
libfoo.so</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ws/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
motif/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my.jar</tt>
<p><b>Packaging target-specific support as a plug-in fragment</b>
<p><tt>install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fragments/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fragmentId>_&lt;version>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fragment.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
os/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;os-name>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(OS-specific files)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ws/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;windowing-system-name>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(WS-specific files)</tt>
<p>For example:
<p><tt>install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fragments/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my.funky.plugin_solaris_1.0.1/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fragment.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
os/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
solaris/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
libfoo.so</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ws/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
motif/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my.jar</tt>
<p>The actual target identifiers for each supported OS and WS are defined
by Eclipse (see Javadoc for <tt>org.eclipse.core.boot.BootLoader</tt>).
<p>The runtime mechanisms, fragment.xml format and APIs for managing target-specific
directories and fragments are described elsewhere in Eclipse platform documentation.
<h3>
<a NAME="Packaging_Support_Deliverables"></a>Packaging Support Deliverables</h3>
Additional support files may be packaged directly within the plug-in directories,
or as fragments. These may include samples, examples, developer reference
documentation, test cases, or other information not directly providing
the base user function. In general the platform does not specify the placement
and use of these files. However, when packaged as fragments, the platform
provides support for accessing the combined plug-in/ fragment space as
a single logical tree. This allows the base plug-in to contain only the
primary user support, and delivers the additional information only when
the necessary fragments are also present.
<h3>
<a NAME="attrib"></a>Packaging Attribution Information</h3>
Eclipse allows vendor attribution information to be be provided for the
main product configuration, as well as for each plug-in.
<p>Main product attribution information is provided by creating a product-level
plug-in, and including <tt>product.ini</tt> file within that plug-in. The
identifier and version of the plug-in must exactly match the identifier
and version of the main product configuration. The format of the <tt>product.ini</tt>
file is defined elsewhere. You can also refer to the Eclipse SDK product-level
plug-in as an example.
<p>Individual plug-ins can also contain attribution information. This is
in the form of an html page supplied as <tt>plugin.html</tt> and placed
in the plug-in directory.
<p>Both the product as well as plug-in attribution information can be viewed
in the Eclipse "About" dialog.
<h2>
<a NAME="Installation_Structure"></a>Installation Structure</h2>

<h3>
<a NAME="Full_vs_Reference_Install"></a>Full vs. Reference Install</h3>
Eclipse supports 2 types of installations:
<ol>
<li>
Full installation. This is the resulting file system structure after the
execution of the installation process. The files are located in the files
system in a way required by the Eclipse platform for direct execution.
Eclipse function can only be directly executed from full installation.</li>

<li>
Reference installation. This is the file structure that exists at an Eclipse
update location used for selecting installable components and configurations</li>
</ol>

<h3>
<a NAME="File_System_Mapping_Full_Install"></a>File System Mapping: Full
Install</h3>
A full installation is defined as the output of the installation process,
whether it was as a result of a "traditional" install, or as a result of
the update manager action. The Eclipse platform can execute directly from
a full installation.
<p>A full Eclipse installation contains the following file structure:
<p><tt>&lt;installation root>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; install.properties</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;componentId>_&lt;version>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install_&lt;locale>.properties (optional)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; configurations/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;configurationId>_&lt;version>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install_&lt;locale>.properties (optional)</tt>
<p><tt>&nbsp;&nbsp;&nbsp; plugins/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;main_configurationId>_&lt;version>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
plugin.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
product.ini</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(other files referenced by product.ini)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;pluginId>_&lt;version>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
plugin.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(other plug-in files)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fragments/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fragmentId>_&lt;fragmentVersion>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fragment.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(other fragment files, may also include plugin.xml)</tt>
<p>The definition of the directories and files is as specified before for
component and configuration jars. The plug-in directory identified by <tt>&lt;main_configurationId>_&lt;version>
</tt>contains the plug-in supplying the product attribution information.
The identifier and version must correspond to the value of the <tt>application.configuration</tt>
attribute described below.
<p>File install.properties contains configurable launch properties. It
reflects the current launch setup for the platform and the installed application.
Its exact use is described in section "Launching Eclipse". This file is
initially installed as part of a new installation. It is subsequently updated
only by the update manager each time the Eclipse installation is updated.
If the file is updated by some other means in a fashion incompatible with
the original installation, the last valid state is restored.
<p>The file is in the form of a Java properties file, and contains the
following:
<p><tt>application=&lt;applicationId></tt>
<br><tt>application.configuration=&lt;configurationId>_&lt;version></tt>
<br><tt>runtime=&lt;pluginId>_&lt;version></tt>
<p>For example
<p><tt>application=</tt>
<br><tt>application.configuration=com.ibm.wsa_1.0.3</tt>
<br><tt>runtime=org.eclipse.core.boot_1.1.4</tt>
<p>The property definitions are as follows:
<ul>
<li>
application - the identifier of the application to run. This is an identifier
of an extension registered into the org.eclipse.core.runtime.applications
extension point. This is the actual application code that will be launched
by the platform. If not specified, it defaults to the Eclipse-supplied
workbench</li>

<li>
application.configuration - directory name (within the install/configurations/
tree) of the configuration corresponding to this application. It can contain
any application-specific launch files (eg. splash image). This allows the
launcher to select the correct version of these files to use on startup.</li>

<li>
runtime - directory name (within the plugins/ tree) of the location of
the Eclipse platform boot.jar. This allows the launcher to select the correct
version of the platform to run. The update manager sets this value each
time the platform is updated. If the platform is updated through traditional
installation, this property must be correctly set</li>
</ul>
The installation.properties files is created by the initial installer.
Once installed, the application and runtime properties are allowed to be
updated. Only the version suffix of the application.configuration is allowed
to be updated (but not the "dominant" configuration identifier).
<p><b><i>Note:</i> as specified in this section, the initial installation
of an Eclipse-based product must also install the install.properties file
that reflects the correct initial startup settings. Failing to do so will
result in inability to launch the product.</b>
<h3>
<a NAME="Workspace_Files"></a>Workspace Files</h3>
In a typical single user configuration, the &lt;installation root> will
also contain the user workspace files. These are created once the platform
is started. In a multi-workspace configuration, the platform is started
up with an explicit workspace directory specified. Any files created as
part of the platform execution are written into the workspace directories.
Note, that in the multi-workspace scenario, the user must ensure only one
instance of update manager is running at any one given time. If the multi-workspace
configuration in fact represents a multi-user shared install, the shared
installation "administrator" should make sure the individual users only
have read access to the installation root.
<h3>
<a NAME="File_System_Mapping_Reference_Install"></a>File System Mapping:
Reference Install</h3>
The reference install file structure is similar to the full install. It
contains the following:
<p><tt>&lt;installation root>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install.index (optional)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;componentId>_&lt;version>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install_&lt;locale>.properties (optional)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;componentId>_&lt;version>.jar</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; configurations/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install.index (optional)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;configurationId>_&lt;version>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install.xml</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install_&lt;locale>.properties (optional)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;configurationId>_&lt;version>.jar</tt>
<p>The reference install can be simply created by partially unzipping the
installation manifest (and any installation resource bundles) from the
component or configuration jar, and then copying the entire jar into the
resulting directory structure (as a peer to the install.xml). Exposing
the install.xml allows the update manager to determine what is available
at a given site. Once selected, the corresponding .jar is downloaded and
installed.
<p>When the reference install site is accessed by protocol other than direct
file i/o, the site must also contain the optional install.index (in components/
and configurations/ directories). This file is a simple directory "table
of contents". It contains the actual subdirectory names on separate lines.
<p>For example:
<p><tt>&lt;installation root>/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; install/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; components/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
install.index</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
org.eclipse.platform_1.0.1/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
org.eclipse.jdt_2.9.5/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
org.eclipse.pde_1.0.4/</tt>
<p>The file install.index would contain
<p><tt>org.eclipse.platform_1.0.1</tt>
<br><tt>org.eclipse.jdt_2.9.5</tt>
<br><tt>org.eclipse.pde_1.0.4</tt>
<p>The install.index file is not required when referencing the "site" through
direct file i/o (as "file" URL). Note, however, that if the file is present,
it is used even in the case of direct file i/o access. This way, the file
can be used by the site administration to control which configurations
and components are actually exposed. In general this is useful when the
components contained in configurations are not intended to be downloaded
and installed as separate items (ie. only managed via some configuration).
In this case the configurations would be directly exposed, but not the
components. The components would only be located via the exposed configurations.
<h2>
<a NAME="Launching_Eclipse"></a>Launching Eclipse</h2>
Before addressing some of the update considerations, it is important to
understand how Eclipse platform is started up. The following are involved:
<ol>
<li>
the installation root directory contains the "product" launch command.
This can either be a simple command "script" (eg: .bat), or the function
of this script can be performed by a simple executable launcher (eg: .exe).
In either case, the launch command does 3 things</li>

<ul>
<li>
reads the install.properties file (see previous description of its content).
Locates the splash image in the application configuration directory (application.configuration
property) and displays it.</li>

<li>
selects the JVM to run and launches it (either via the java command, or
by loading the JVM executables directly). The jre selection criteria include
explicitly passed jre location, location relative to the launcher,&nbsp;
or environment variable setting (sharing common jre on the system)</li>

<li>
causes the class Main from startup.jar to be loaded and its main(...) method
executed</li>
</ul>

<li>
Main is passed the location of the eclipse platform executables (runtime
property)
and the identifier of an application the platform is to execute (application
property, the workbench is the default application supplied by Eclipse).
Main locates the platform boot.jar and loads the platform BootLoader from
it. It gives control to the BootLoader passing the identifier of the application
as an argument (plus any other startup arguments)</li>

<li>
The BootLoader causes the platform core runtime to start up. This causes
the plug-in registry to be loaded and resolved (configuring the plug-ins
that will be eligible for execution)</li>

<li>
The BootLoader looks up the application name (passed in as argument) in
the plug-in registry, and if found, activates the application plug-in and
gives it control.</li>

<li>
The started application (eg. workbench) activates and calls other plugins
as appropriate</li>
</ol>
<b><i>Note:</i> The default launcher supplied with the current version
of the Eclipse platform does not in fact process the <tt>install.properties
</tt>file
(as described in steps 1 and 2 above). It simply locates the default splash
screen and platform runtime relative to itself.</b>
<h2>
<a NAME="Update_Considerations"></a>Update Considerations</h2>

<h3>
<a NAME="Updating_Non_Platform_Components"></a>Updating Non-Platform Components</h3>
Non-platform components deliver plug-ins that execute "on top" of the platform.
The update manager simply installs the required plug-in directories and
files. These are detected and processed next time the platform starts.
<p>The update manager never updates an existing plug-in directory structure.
It only installs a version of a plug-in that did not previously exist.
If the plug-in directory already exists (eg. included in some other (version
of the) component), it is not installed again. The update manager does
not verify that the existing directory content matches the one in the component
jar. Consequently, the plug-in version identifier must be correctly reflected
in the plug-in directory name.
<h3>
<a NAME="Updating_the_Platform"></a>Updating the Platform</h3>
The current version of the Eclipse platform does not allow the platform
itself to be updated using the update manager. Platform updates need to
be handled through traditional installation mechanisms.
<h3>
<a NAME="Updating_JRE"></a>Updating JRE</h3>
The current version of the Eclipse platform does not allow the JRE to be
updated using the update manager. JRE updates need to be handled through
traditional installation mechanisms.
<h3>
<a NAME="Updating_Launch_Support"></a>Updating Launch Support</h3>
The current version of the Eclipse platform does not allow the launcher
(.exe, startup.jar) to be updated using the update manager. Launcher updates
need to be handled through traditional installation mechanisms.
<h3>
<a NAME="Recovering_from_Update_Failures"></a>Recovering from Update Failures</h3>
There are two scenarios to consider.
<ol>
<li>
controlled failures - these are various access, download, unzip, etc. failures
detected by the update manager. The update manager contains logic to recover
from these failures</li>

<li>
"uncontrolled" failures - these are sudden failure (eg: loss of power)
in the middle of update processing before the update manager had a chance
to complete its operation. These are detected on platform startup. The
installation tree is verified against the last known state and any partial
changes are removed from the installation tree.</li>
</ol>

<h3>
<a NAME="Recovering_from_Bad_Updates"></a>Recovering from Bad Updates</h3>
The update manager maintains a descriptions of the current configuration
state of the installation. This includes the list of "active" configurations
and components (the actual installation tree may contain additional configurations
and component versions that are effectively hidden as a result of subsequent
updates).
<p>Each time the update manager updates and saves this information (save
is done on platform shutdown), the state information is cloned, and the
previous state is kept as a chronological sequence of updates. The update
manager maintains several generations of state (number of previous states
is a settable option). Old versions of the state and the corresponding
configurations and components are regularly collected (deleted) as part
of update manager cleanup processing.
<p>The back-level copies of the state provide a mechanism for recovering
from bad updates. In this scenario "bad" means the update manager successfully
downloaded and applied a change, but the change is causing problems.
<h3>
<a NAME="Installation_Cleanup"></a>Installation Cleanup</h3>
The update manager periodically trims the content of the installation tree.
Only components and configurations references in several most recent generations
of the update state are retained (the number of retained states is a settable
option). The cleanup is performed as part of the update manager operation
and need not be explicitly triggered.
<h3>
<a NAME="Unmanaged_Eclipse_Function"></a>Unmanaged Eclipse Function</h3>
In addition to "formally" installed configurations and components, the
Eclipse platform also tolerates plug-ins and plug-in fragments that are
directly placed into the installation tree without any corresponding installation
manifests describing these. These plug-ins and fragments are recognized
at runtime, but cannot be updated or removed using the update manager functions
(are "unmanaged"). This support is specifically geared at plug-in development
scenarios in an attempt to eliminate the installation/ packaging development
overhead. Traditional installer should not install unmanaged plug-ins and
fragments.
<h2>
<a NAME="Installation_Considerations"></a>Installation Considerations</h2>
From an installation point of view, Eclipse makes a distinction between
an installation that establishes a new Eclipse platform base (jre, platform
and the "dominant" application), and one that simply contributes (merges)
new components into an existing base.
<h3>
<a NAME="New_Installation"></a>New Installation</h3>
At present, a new platform installation must be done using a traditional
installation technology, such as Windows MSI installer, RPM, InstallShield,
or a simple archive mechanism (eg. a .zip file). The installer is responsible
for ensuring the resulting file structure (after the completion of the
nstallation) follows the specification described in this document.
<p>The installer needs to perform the following:
<ul>
<li>
establish a new Eclipse platform installation root</li>

<li>
optionally register the new platform root with the appropriate OS-specific
registry</li>

<li>
install a copy of the Java Runtime Environment (JRE), or ensure an existing
JRE is properly configured for use with Eclipse</li>

<li>
install Eclipse platform (minimally the org.eclipse.core and org.eclipse.ui
components)</li>

<li>
install the "dominant" application configuration. Typically, this includes
the full application configuration plus all the required components (and
their corresponding plug-ins and fragments). Minimally, install a "placeholder"
configuration for the application specifying an update location containing
the actual application function (note, that in the current implementation
the user must explicitly trigger the download/ update after starting Eclipse).</li>

<li>
install the initial install.properties file as described previously (startup
configuration settings).</li>
</ul>
A corresponding "traditional" uninstaller must be provided to remove the
"dominant" application and its Eclipse platform tree. In general, the uninstaller
is responsible for reversing the actions of its installer. Note, however,
that because the content of the Eclipse installation tree can change as
a normal part of using the Eclipse update manager, the "traditional" uninstaller
may not actually find the files that were originally installed. Some of
the files may no longer exist (were removed by update manager), and the
installation tree may now contain additional files that were not originally
installed (eg. applied updates). As a result, a "traditional" uninstaller
relying strictly on the install log will generally not be able to completely
remove the application installation.
<p>To compensate for changes made by the update manager the "traditional"
uninstaller can force the removal of all files within the following Eclipse
installation directories:
<ul>
<li>
install/ - contains installation configuration information (no user data)</li>

<li>
plugins/ - contains plug-in executables, etc (no user data)</li>

<li>
fragments/ - contains plug-in fragment executables, etc (no user data)</li>
</ul>
Other directories found in the installation tree may contain user data
and should not be removed.
<h3>
<a NAME="Merged_Installation"></a>Merged Installation</h3>
Once an Eclipse platform installation is established (see previous section),
additional components and configurations can be added into the platform
using the Eclipse update manager, or a "traditional" installer. In the
later case the installer is responsible for ensuring the resulting file
structure (after the completion of the installation) follows the specification
described in this document.
<p>The installer needs to perform the following:
<ul>
<li>
automatically detect the location of an installed Eclipse platform (on
systems supporting a registration mechanism (see below)), or prompt the
user for such location</li>

<li>
install the appropriate configurations and components (together with the
corresponding plug-ins and fragments)</li>

<li>
optionally save a merged installation "root" file to be used during "traditional"
uninstall (see below)</li>
</ul>
Using "traditional" unistaller for merged installation requires additional
care. In general, unistallers should never attempt to remove the actual
installed program files. The reason is that the files that were originally
installed may no longer exist, or some of the files that were installed
have been updated as normal part of Eclipse operation. As a result, attempting
to directly remove the original installed files may, at best, work correctly,
or have no effect at all, and at worst, may result in removing some arbitrary
portion of the installed support (causing unpredictable failures at next
launch of the application). This is further aggravated when components
or plug-ins are shared. Only in the case where a configuration or a component
is guaranteed not to have been updated, and is guaranteed not to be shared,
could its files be directly removed.
<p>Care should be taken when using installer technologies that do not allow
the above control over the uninstall process (ie. suppress removal of installed
files). RPM on Linux is one such example. In these cases the particular
installer technology should be avoided for merged installations, or the
resulting uninstall should never be executed.
<p>A "traditional" unistaller can support safe removal of installed function
by using the merged installation "root" files. These are optionally installed
as part of the merged installation and act as an anchor for the corresponding
configurations and components. Eclipse platform detects removal of the
"root" files during startup, and safely removes the listed configurations
and components.
<p>Note: unlike the configuration and component files themselves, the "root"
files are not subject to changes by the update manager. Consequently a
"traditional" uninstaller can rely of these to remain in place once installed.
<p>When installed, the "root" files are placed in the install/info/ directory
within the Eclipse installation tree (peer to install/configurations and
install/components directories). The files use the following naming convention:
<p><tt>&lt;merged-installation-identifier>.install</tt>
<p>Eclipse platform does not specify the format of the identifier (is not
interpreted in any way). To minimize the opportunity for naming conflicts,
it is strongly recommended that the identifier use a naming convention
based on the provider internet domain name (eg. <tt>com.xyz.toolpack.install</tt>).
<p>The content of the "root" file uses Java property file format, containing
the following:
<p><tt>configurations=[&lt;configId>_&lt;version> [, &lt;configId>_&lt;version>]*
]</tt>
<br><tt>components=[&lt;compId>_&lt;version> [,&lt;compId>_&lt;version>]*
]</tt>
<p>where
<br><tt>[]optional element</tt>
<br><tt>* repeating group</tt>
<p>(in plain english, both properties are a comma-separated list of the
corresponding version-suffixed identifiers)
<h3>
<a NAME="Platform_Specific_Registration"></a>Platform-Specific Registration</h3>
<b><i>Note:</i> this section describes a suggested "best practice". However,
it is not required for correct execution of the Eclipse platform.</b>
<p>It is suggested that Eclipse-based products use a OS registration mechanism
to keep track of all the locations of installed Eclipse platforms. This
allows for a simple lookup when deciding whether to create a new platform
installation, or merge components into an existing one. On platforms where
such registration mechanism is not provided, the user will be prompted
to explicitly identify Eclipse installation directories.
<p>The installer typically offers to create a new installation, or to merge
components into an existing installation. Creating new installation should
also update the registration structures.
<p>On Windows, the Windows registry is used for this purpose. The following
is the suggested registry key structure for identifying Eclipse platform
installation directories:
<p><tt>eclipse.org/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; platforms/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;product name></tt>
<p>The <tt>&lt;product name></tt> key identifies the provider and/ or the
dominant application that created the new Eclipse platform installation.
The full key maps to the following attributes
<p><tt>label =</tt> displayable label for the <tt>&lt;product name></tt>
key. Localized at time of creation.
<br><tt>directory =</tt> &lt;absolute path>
<h2>
<a NAME="Development_Considerations"></a>Development Considerations</h2>

<h3>
<a NAME="Installation_Location_Independence"></a>Installation Location
Independence</h3>
The Eclipse API allows an executing plug-in to obtain a reference to its
installation directory. This is accomplished by calling <tt>IPluginDescriptor.getInstallURL()</tt>.The
call returns java.net.URL. Executing plug-ins access all required resources
relative to this URL. The URL protocol support handles the required redirection
to local plug-in directory, plug-in cache, CD (minimal installation) or
server. The typical way a plug-in accesses its resources is by opening
an input stream on the URL and reading the content of the resource. Since
the installation location is assumed to be read-only, the executing plug-in
should never attempt to write using the returned URL.
<h3>
<a NAME="Native_Executables"></a>Native Executables</h3>
Java native libraries used by Eclipse plug-ins do not require any special
handling. These are installed as part of the plug-in directory structure
and loaded by the platform class loader (jdk 1.2+).
<p>OS-specific native components (such as ActiveX) require custom installation
not handled by the Eclipse update manager. The custom installer registers
the components with the appropriate OS services and updates any standard
search paths. The Eclipse platform does not provide any automated checking
for required native components. The plug-in code is required to implement
the necessary checking/ recovery logic. It is possible to create a "marker"
plug-in as part of the custom installer to indicate presence of some native
component and allow other plug-ins to specify the dependency. However,
this approach is not foolproof and cannot be used as an absolute guarantee
of a satisfied native dependency.
<h3>
<a NAME="Concurrent_Plug_In_Version_Support"></a>Concurrent Plug-In Version
Support</h3>
The Eclipse platform allows multiple versions of one plug-in to be concurrently
installed. This covers scenarios where a user installs two Eclipse-based
products containing different versions of the same plug-in. Both versions
can be installed into the common program root. Depending on configuration
rules (discussed later), the platform usually only uses the most recent
version of the plug-in during execution. However, if the user subsequently
uninstalls one of the products, the installation structure of the other
product is left unchanged (ie. contains the correct version of the plug-in
that was installed with the product).
<p>The Eclipse platform also allows multiple versions of the same plug-in
to be concurrently configured and executed. This is specifically geared
at plug-ins containing shared runtime libraries. A given user of the shared
runtime may want to specify a dependency on a specific version of the plug-in.
Such a plug-in must only declare its runtime libraries (in the &lt;runtime>
section of plugin.xml), and must not declare any ther contributions to
the platform (specifically must not declare extension point(s) and/or contribute
extensions).
<p>In order to support this, the Eclipse platforms defines a scheme for
identifying plug-ins, convention for naming plug-in directories within
the file system, and a set of rules for configuring and executing plug-ins
located during platform startup.
<p>Plug-ins are identified by a combination of a structured string resembling
Java package name and a multi-decimal version identifier. The version identifier
consists of a major component indicating an incompatible generation and
a minor component indicating a compatible evolution of the plug-in.
<ul>
<li>
id - unique identifier for the plug-in. It is a structured string resembling
Java package name. The identification scheme avoids naming collisions through
a simple hierarchical naming convention based on registered internet domain
names of individual vendors producing plug-ins. For example, org.eclipse.ui,
edu.xyz.tools are valid examples of plug-in unique identifiers.</li>

<li>
version - a multi-decimal identifier. It follows the definition described
for PliginVersionIdentifier class (major.minor.service)</li>
</ul>
Since multiple versions of the same plug-in can be physically installed
into the same file tree, the individual plug-in directories must be uniquely
identified to prevent multiple versions of the same plug-in to be accidentally
overlaid. The recommended plug-in directory name is the combination of
plug-in unique identifier and the version identifier. The underscore "_"
character is used to separate the version string from the name string.
Below are examples of directory names for the corresponding plug-ins.
<br>&nbsp;
<table BORDER COLS=3 WIDTH="100%" >
<tr>
<td>Plug-in</td>

<td>Version</td>

<td>Recommended Directory Name</td>
</tr>

<tr>
<td>org.eclipse.ui</td>

<td>1.3.17</td>

<td>org.eclipse.ui_1.3.17</td>
</tr>

<tr>
<td>edu.xyz.tools</td>

<td>1.0.1</td>

<td>edu.xyz.tools_1.0.1</td>
</tr>
</table>

<p>The platform provides an API for dealing with version identifiers
<ul>
<li>
IPluginDescriptor.getVersionIdentifier() - returns the version identifier
for a specific plug-in</li>

<li>
class implementation of PluginVersionIdentifier. Methods on this class
allow access to the major and minor components of the identifier. They
also implement matching for version equality and compatibility</li>
</ul>
There is an additional consideration for plug-ins that allow concurrent
execution and also write plug-in state or working data (see Plugin.getPluginStateLocation()
and IProject.getPluginWorkingLocation(IPluginDescriptor)). Beyond issues
with version migration (see next section), the plug-ins are also responsible
for managing concurrent access from multiple executing versions of the
same plug-in to any shared plug-in resources. The plug-ins must use facilities
of the selected file access APIs to coordinate concurrent access.
<h3>
<a NAME="Version_Migration"></a>Version Migration</h3>
Because of the dynamic nature of the platform configuration, plug-in implementations
must be aware of migration issues that can arise while executing. Unlike
traditional products, Eclipse-based solutions really do not "come together"
until the user starts the platform.
<p>The platform provides base facilities that can be used by the plug-in
for handling each of the migration situations, however, ultimately it is
the responsibility of the plug-in developer to use these correctly.
<p>As plug-ins execute, they can write plug-in specific information into
several working locations. References to the working locations are obtained
using the following API calls
<ul>
<li>
Plugin.getPluginStateLocation() - returns the platform-wide working state
location for the plug-in</li>

<li>
IProject.getPluginWorkingLocation(IPluginDescriptor) - returns the plug-in
working location within the referenced project</li>
</ul>
Each plug-in is responsible for handling the migration of its working data.
There are two basic scenarios for plug-ins to consider
<ol>
<li>
forward migration - a new version of a plug-in was configured and it needs
to migrate the data written by the previous version. This is based on the
assumption version n+1 of a plug-in can read data written by version n
of the same plug-in.</li>

<li>
backward migration - a version of a plug-in that was configured in a prior
invocation of the platform is removed, and an older version of the same
plug-in becomes configured (the more recent version was hiding the older
version). This is a more troublesome scenario because one cannot generally
assume version n of a plug-in can read data written by version n+1 of the
same plug-in.</li>
</ol>
The forward migration scenario requires the new version of the plug-in
to detect the data written by the prior version, and to read, convert and
rewrite the data. This can be performed the first time the new plug-in
version is activated (Plugin.startup()) or while accessing the working
areas. In general, the first approach is more suited to migrating the plug-in
"state" data, and the second to migrating the project data.
<p>Backward migration requires some additional work on the part of the
plug-in developer. In essence, version n+1 of plug-in needs to write data
in such a way that version n can at least detect this situation. There
are several possible techniques plug-ins can use to handle this scenario.
<ul>
<li>
detect incompatible data format and handle it "gracefully" (detecting this
may be via version-stamped data or getting a data error while reading).
If the plug-in data cannot read, revert to initial default behavior (as
if no prior state was found). Downside of this approach is loss of data
(eg. plug-in settings)</li>

<li>
version n+1 writes all base information using version n format, and creates
separate files (not recognized by n) for any extended information. Version
n+1 must tolerate the base files and the extension files being out of synch
(n+1 migrated to n and then migrated back to n+1)</li>

<li>
use self-describing serialization format that identifies base content and
version-specific extensions. The extensions can carry additional qualifiers
(eg. "ignore if not understood", "must understand", etc). Version n of
a plug-in can read data written by version n+1 (modulo any qualifier rules).
If version n updates any of the base data, it rewrites the file with version
n+1 extensions intact. Extensions qualified with "must understand" are
not rewritten. Version n+1 must tolerate the base content and the extensions
being out of synch (n+1 migrated to n and then migrated back to n+1)</li>
</ul>
The plug-in developer is responsible for choosing the appropriate implementation
strategy. The platform does not provide any specific APIs for automatically
managing migration of plug-in data.
<br>&nbsp;
<p><a href="hglegal.htm"><img SRC="ngibmcpy.gif" BORDER=0 height=12 width=250></a>
</body>
</html>
