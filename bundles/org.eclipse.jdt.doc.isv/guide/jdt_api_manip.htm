<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>Manipulating Java code</TITLE>

<link rel="stylesheet" type="text/css" HREF="../book.css">
</HEAD>
<BODY BGCOLOR="#ffffff">
<H2>
Manipulating Java code</H2>
<P>
Your plug-in can use the JDT API to create classes or interfaces, add methods to existing types, or alter the methods for types. </P>
<P>
The simplest way to alter Java objects is to use the Java element API. More general techniques can be used to work with the raw source code for a Java element.</P>

<H3>
Code modification using Java elements</h3>

<H4>
Generating a compilation unit
</h4>
<P>
The easiest way to programmatically generate a compilation unit is to use <b>IPackageFragment.createCompilationUnit</b>. You specify the name and contents of the compilation unit. The compilation unit is created inside the package and the new
<b><a href="../reference/api/org/eclipse/jdt/core/ICompilationUnit.html"> ICompilationUnit</a></b> is returned. </P>
<P>
A compilation unit can be created generically by creating a file resource whose extension is &quot;<b>.java&quot;</b> in the appropriate folder that corresponds to the package directory. Using generic resource API goes &quot;behind the back&quot; of the Java tooling, so the Java model is not updated until the generic resource change listeners are
notified and the JDT listeners update the Java model with the new compilation unit.</P>


<H4>
Modifying a compilation unit
</h4>
<P>
Most simple modifications of Java source can be done using the Java element API.</P>
<P>
For example, you can query a type from a compilation unit. Once you have the <a href="../reference/api/org/eclipse/jdt/core/IType.html"><b>IType</b></a>, you can use protocol such as
<b>createField</b>, <b>createInitializer</b>,
<b>createMethod</b>, or <b> createType</b> to add source code members to the type. The source code and information about the location of the member is supplied in these methods.</P>
<P>
The <b><a href="../reference/api/org/eclipse/jdt/core/ISourceManipulation.html"> ISourceManipulation</a></b> interface defines common source manipulations for java elements. This includes methods for renaming, moving, copying, or deleting a type's member. </P>


<H4>
Working copies
</h4>
<P>
Code can be modified by manipulating the compilation unit (and thus the underlying <b>IFile</b> is modified) or
one can modify an in-memory copy of the compilation unit called a working copy. </P>
<P>
A working copy is obtained from a compilation unit using the 
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#getWorkingCopy()">getWorkingCopy</a></b>
method.  Whoever creates such a working copy is responsible for destroying it when not needed any longer using the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#destroy()">destroy</a></b>
method. </P>
<P>
Working copies modify an in-memory buffer. The <b>getWorkingCopy()</b> method creates a default buffer, but
clients can provide their own buffer implementation using the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#getWorkingCopy(org.eclipse.core.runtime.IProgressMonitor, org.eclipse.jdt.core.IBufferFactory, org.eclipse.jdt.core.IProblemRequestor)">getWorkingCopy(IProgressMonitor, IBufferFactory, IProblemRequestor)</a></b>
method. Clients can manipulate the text of this buffer directly. If they do so, they must synchronize the working copy with
the buffer from time to time using either the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#reconcile()">reconcile()</a></b>
method or the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#reconcile(boolean, org.eclipse.core.runtime.IProgressMonitor)">reconcile(boolean,IProgressMonitor)</a></b>
method.  </P>
<P>
Finally a working copy can be saved to disk (replacing the original compilation unit) using the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#commit(boolean, org.eclipse.core.runtime.IProgressMonitor)">commit</a></b>
method. </P>
<P>
For example the following code snippet creates a working copy on a compilation unit using a custom buffer factory, it
modifies the buffer, it reconciles the changes, it commits the changes to disk and it finally destroys the working copy. </P>
<font color='#4444CC'><pre>
    // Get original compilation unit
    ICompilationUnit originalUnit = ...;
    
    // Get buffer factory
    IBufferFactory factory = ...;
    
    // Create working copy
    IWorkingCopy workingCopy = originalUnit.getWorkingCopy(null, factory, null);
    
    // Modify buffer and reconcile
    IBuffer buffer = ((IOpenable)workingCopy).getBuffer();
    buffer.append("class X {}");
    workingCopy.reconcile();
    
    // Commit changes
    workingCopy.commit(false, null);
    
    // Destroy working copy
    workingCopy.destroy();
</pre></font>
<P>
Working copies can also be shared by several clients. Such a working copy is created using the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#getSharedWorkingCopy(org.eclipse.core.runtime.IProgressMonitor, org.eclipse.jdt.core.IBufferFactory, org.eclipse.jdt.core.IProblemRequestor)">getSharedWorkingCopy</a></b>
method and it can be later retrieved using the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#findSharedWorkingCopy(org.eclipse.jdt.core.IBufferFactory)">findSharedWorkingCopy</a></b>
method. A shared working copy is thus keyed on the original compilation unit and a buffer factory.</P>
<P>
The following shows how client 1 creates a shared working copy, client 2 retrieves this working copy, client 1 destroys the
working copy, and client 2 trying to retrieve the shared working copy notices it does not exist any longer: </P>
<font color='#4444CC'><pre>
    // Client 1: Get original compilation unit
    ICompilationUnit originalUnit = ...;
    
    // Client 1: Get buffer factory
    IBufferFactory factory = ...;
    
    // Client 1: Create shared working copy
    IWorkingCopy workingCopyForClient1 = originalUnit.getSharedWorkingCopy(null, factory, null);
    
    // Client 2: Retrieve shared working copy
    IWorkingCopy workingCopyForClient2 = originalUnit.findSharedWorkingCopy(factory);
     
    // This is the same working copy
    assert workingCopyForClient1 == workingCopyForClient2;
    
    // Client 1: Destroy shared working copy
    workingCopyForClient1.destroy();
    
    // Client 2: Attempt to retrieve shared working copy and find out it's null
    workingCopyForClient2 = originalUnit.findSharedWorkingCopy(factory);
    assert workingCopyForClient2 == null;
</pre></font>

<H3>Code modification using the DOM/AST API</h3>

There are two ways to create a <b><a href="../reference/api/org/eclipse/jdt/core/dom/CompilationUnit.html">CompilationUnit</a></b>. The first one is to use an existing compilation unit. The second
is to start from scratch using the factory methods on <b><a href="../reference/api/org/eclipse/jdt/core/dom/AST.html">AST</a></b>.
<h4>
Creating an AST from an existing compilation unit
</h4>
This is archieved with the parse methods on <b><a href="../reference/api/org/eclipse/jdt/core/dom/AST.html">AST</a></b>.
<ul>
<li><a href="../reference/api/org/eclipse/jdt/core/dom/AST.html#parseCompilationUnit(char[])">parseCompilationUnit(char[])</a> This method should be used if you simply
want to create a <b><a href="../reference/api/org/eclipse/jdt/core/dom/CompilationUnit.html">CompilationUnit</a></b> without any binding resolution. Only syntax errors are
reported using this method.
</li>
<li><a href="../reference/api/org/eclipse/jdt/core/dom/AST.html#parseCompilationUnit(char[], java.lang.String, org.eclipse.jdt.core.IJavaProject)">parseCompilationUnit(char[] source, String unitName, IJavaProject project)</a>. This method can be used to create a
<b><a href="../reference/api/org/eclipse/jdt/core/dom/CompilationUnit.html">CompilationUnit</a></b> from a byte array. If the IJavaProject is specified, the bindings can be resolved. In this case, the name of the compilation unit is used for
the binding resolution. 
</li>
<li><a href="../reference/api/org/eclipse/jdt/core/dom/AST.html#parseCompilationUnit(org.eclipse.jdt.core.ICompilationUnit, boolean)">parseCompilationUnit(ICompilationUnit unit, boolean resolveBindings)</a>. This method can be used to create a
<b><a href="../reference/api/org/eclipse/jdt/core/dom/CompilationUnit.html">CompilationUnit</a></b> from an existing <b><a href="../reference/api/org/eclipse/jdt/core/ICompilationUnit.html">ICompilationUnit</a></b>.
</li>
</ul>
All these methods will properly set the positions for each node in the resulting tree. The resolution of bindings has to be requested
before the creation of the tree. Resolving the bindings is a costly operation and should be done only when necessary. As soon as the tree has been modified, all positions and
bindings are lost.

<h4>
From scratch
</h4>
<P>It is possible to create a <b><a href="../reference/api/org/eclipse/jdt/core/dom/CompilationUnit.html">CompilationUnit</a></b> from scratch using the factory methods on <b><a href="../reference/api/org/eclipse/jdt/core/dom/AST.html">AST</a></b>.
These method names start with <b>new...</b>. Here is a small example that creates a <b>HelloWorld</b> class.
</P>
<P>First it is the java source:
<font color='#4444CC'><pre>
	package example;
	import java.util.*;
	public class HelloWorld {
		public static void main(String[] args) {
			System.out.println("Hello" + " world");
		}
	}
</pre></font>
</P>
<P>Then it is the corresponding code using the factory methods.
<font color='#4444CC'><pre>
		CompilationUnit unit = this.ast.newCompilationUnit();
		PackageDeclaration packageDeclaration = this.ast.newPackageDeclaration();
		packageDeclaration.setName(this.ast.newSimpleName("example"));
		unit.setPackage(packageDeclaration);
		ImportDeclaration importDeclaration = this.ast.newImportDeclaration();
		QualifiedName name = 
			this.ast.newQualifiedName(
				this.ast.newSimpleName("java"),
				this.ast.newSimpleName("util"));
		importDeclaration.setName(name);
		importDeclaration.setOnDemand(true);
		unit.imports().add(importDeclaration);
		TypeDeclaration type = this.ast.newTypeDeclaration();
		type.setInterface(false);
		type.setModifiers(Modifier.PUBLIC);
		type.setName(this.ast.newSimpleName("HelloWorld"));
		MethodDeclaration methodDeclaration = this.ast.newMethodDeclaration();
		methodDeclaration.setConstructor(false);
		methodDeclaration.setModifiers(Modifier.PUBLIC | Modifier.STATIC);
		methodDeclaration.setName(this.ast.newSimpleName("main"));
		methodDeclaration.setReturnType(this.ast.newPrimitiveType(PrimitiveType.VOID));
		SingleVariableDeclaration variableDeclaration = this.ast.newSingleVariableDeclaration();
		variableDeclaration.setModifiers(Modifier.NONE);
		variableDeclaration.setType(this.ast.newArrayType(this.ast.newSimpleType(this.ast.newSimpleName("String"))));
		variableDeclaration.setName(this.ast.newSimpleName("args"));
		methodDeclaration.parameters().add(variableDeclaration);
		org.eclipse.jdt.core.dom.Block block = this.ast.newBlock();
		MethodInvocation methodInvocation = this.ast.newMethodInvocation();
		name = 
			this.ast.newQualifiedName(
				this.ast.newSimpleName("System"),
				this.ast.newSimpleName("out"));
		methodInvocation.setExpression(name);
		methodInvocation.setName(this.ast.newSimpleName("println")); 
		InfixExpression infixExpression = this.ast.newInfixExpression();
		infixExpression.setOperator(InfixExpression.Operator.PLUS);
		StringLiteral literal = this.ast.newStringLiteral();
		literal.setLiteralValue("Hello");
		infixExpression.setLeftOperand(literal);
		literal = this.ast.newStringLiteral();
		literal.setLiteralValue(" world");
		infixExpression.setRightOperand(literal);
		methodInvocation.arguments().add(infixExpression);
		ExpressionStatement expressionStatement = this.ast.newExpressionStatement(methodInvocation);
		block.statements().add(expressionStatement);
		methodDeclaration.setBody(block);
		type.bodyDeclarations().add(methodDeclaration);
		unit.types().add(type);
</pre></font>
</P>
<h4>Retrieving extra positions</h4>
The DOM/AST node contains only a pair of positions (the starting position and the length of the node). This is not always
sufficient. In order to retrieve intermediate positions, the <b><a href="../reference/api/org/eclipse/jdt/core/compiler/IScanner.html">IScanner</a></b> API should be used. For example,
we have an <b><a href="../reference/api/org/eclipse/jdt/core/dom/InstanceofExpression.html">InstanceofExpression</a></b> for which we want to know the 
positions of the <i>instanceof</i> operator.
We could write the following method to achieve this:
<font color='#4444CC'><pre>
	private int[] getOperatorPosition(Expression expression, char[] source) {
		if (expression instanceof InstanceofExpression) {
			IScanner scanner = ToolFactory.createScanner(false, false, false, false);
			scanner.setSource(source);
			int start = expression.getStartPosition();
			int end = start + expression.getLength();
			scanner.resetTo(start, end);
			int token;
			try {
				while ((token = scanner.getNextToken()) != ITerminalSymbols.TokenNameEOF) {
					switch(token) {
						case ITerminalSymbols.TokenNameinstanceof:
							return new int[] {scanner.getCurrentTokenStartPosition(), scanner.getCurrentTokenEndPosition()};
					}
				}
			} catch (InvalidInputException e) {
			}
		}
		return null;
	}
</pre></font>
The <b><a href="../reference/api/org/eclipse/jdt/core/compiler/IScanner.html">IScanner</a></b> is used to divide the input source into tokens.
Each token has a specific value that is defined in the <b><a href="../reference/api/org/eclipse/jdt/core/compiler/ITerminalSymbols.html">ITerminalSymbols</a></b> interface. It is 
fairly simple to iterate and retrieve the right token. This is a general approach. It could be used to retrieve the positions of the
<i>super</i> keyword in a <b><a href="../reference/api/org/eclipse/jdt/core/dom/SuperMethodInvocation.html">SuperMethodInvocation</a></b>.
<H3>
Generic source code modification</h3>
<P>
Some source code modifications are not provided via the Java element API. A more general way to edit source code (such as changing the source code for existing elements) is accomplished using the compilation unit's raw source code and the Java DOM.</P>
<P>
These techniques include the following:</P>
<font color='#4444CC'><pre>
   // get the source for a compilation unit
   String contents = myCompilationUnit.getBuffer().getContents();

   // Create an editable JDOM
   myJDOM = new DOMFactory();
   myDOMCompilationUnit = myJDOM.createCompilationUnit(contents, &quot;MyClass&quot;);

   // Navigate and edit the compilation unit structure using 
   // JDOM node protocol. 
   ...
   // Once modififications have been made to all of the nodes 
   // get the source back from the compilation unit DOM node.
   String newContents = myDOMCompilationUnit.getContents();

   // Set this code back into the compilation unit element
   myCompilationUnit.getBuffer().setContents(newContents);

   // Save the buffer to the file.
   myCompilationUnit.save();
</pre></font>
<P>
This technique can result in problem markers being associated with incorrect line numbers, since the Java elements were not updated directly.</P>
<P>
The Java element model does not go any finer than methods and fields. The abstract syntax tree (AST) used by the compiler is not available as API, so the techniques used by the JDT to parse source into programmatic structures are not currently available as API.</P>


<H3>
Responding to changes in Java elements</h3>
<P>
If your plug-in needs to know about changes to Java elements after the fact, you can register a Java
<a href="../reference/api/org/eclipse/jdt/core/IElementChangedListener.html"><b> IElementChangedListener</b></a> with
<a href="../reference/api/org/eclipse/jdt/core/JavaCore.html"><b>JavaCore</b></a>.</P>
<font color='#4444CC'><pre>
   JavaCore.addElementChangedListener(new MyJavaElementChangeReporter());
</pre></font>
<P>
You can be more specific and specify the type of events you're interested in using 
<a href="../reference/api/org/eclipse/jdt/core/JavaCore.html#addElementChangedListener(org.eclipse.jdt.core.IElementChangedListener, int)"><b> addElementChangedListener(IElementChangedListener, int)</b></a>. </P>
<P>
For example, if you're only interested in listening for events before the builders run: </P>
<font color='#4444CC'><pre>
   JavaCore.addElementChangedListener(new MyJavaElementChangeReporter(), ElementChangedEvent.PRE_AUTO_BUILD);
</pre></font>
<P>
There are three kinds of events that are supported by <b>JavaCore</b>:
<ul>
<li><a href="../reference/api/org/eclipse/jdt/core/ElementChangedEvent.html#POST_CHANGE"><b>POST_CHANGE</b></a>: 
      Listeners of this event kind will get notified during the corresponding <b>POST_CHANGE</b> 
      resource change notification.</li>
<li><a href="../reference/api/org/eclipse/jdt/core/ElementChangedEvent.html#PRE_AUTO_BUILD"><b>PRE_AUTO_BUILD</b></a>: 
      Listeners of this event kind will get notified during the corresponding <b>PRE_AUTO_BUILD</b> 
      resource change notification.</li>
<li><a href="../reference/api/org/eclipse/jdt/core/ElementChangedEvent.html#POST_RECONCILE"><b>POST_RECONCILE</b></a>: 
      Listeners of this event kind will get notified at the end of a reconcile operation on a working copy
      (see <a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#reconcile()"><b>IWorkingCopy.reconcile()</b></a>).</li>
</ul> </P>
<P>
Java element change listeners are similar conceptually to resource change listeners
(described in
<a HREF="../../org.eclipse.platform.doc.isv/guide/resAdv_events.htm" CLASS="XRef">tracking resource changes</a>). The following snippet implements a Java element change reporter that prints the element deltas to the system console.</P>
<font color='#4444CC'><pre>
   public class MyJavaElementChangeReporter implements IElementChangedListener {
      public void elementChanged(ElementChangedEvent event) {
         IJavaElementDelta delta= event.getDelta();
         if (delta != null) {
            System.out.println(&quot;delta received: &quot;);
            System.out.print(delta);
         }
      }
   }
</pre></font>
<P>
The <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html"><b> IJavaElementDelta</b></a> includes the element that was
changed and flags describing the kind of change that occurred. </P>
<P>
Several kinds of operations can trigger a Java element change notification. Here are some examples:
<ul>
<li>Creating a resource, e.g. <a href="../reference/api/org/eclipse/jdt/core/IPackageFragment.html#createCompilationUnit(java.lang.String, java.lang.String, boolean, org.eclipse.core.runtime.IProgressMonitor)"><b>IPackageFragment.createCompilationUnit</b></a> 
      (the delta indicates the <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#ADDED">addition</a> of the compilation unit)</li>
<li>Modifying a resource, e.g. <a href="../reference/api/org/eclipse/jdt/core/ICompilationUnit.html#createType(java.lang.String, org.eclipse.jdt.core.IJavaElement, boolean, org.eclipse.core.runtime.IProgressMonitor)"><b>ICompilationUnit.html.createType</b></a> 
     (the delta indicates that the compilation unit has <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#CHANGED">changed</a> and that a type was 
     <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#getAddedChildren()"> added as a child</a> of this compilation unit)</li>
<li>Modifying a project's classpath, e.g. <a href="../reference/api/org/eclipse/jdt/core/IJavaProject.html#setRawClasspath(org.eclipse.jdt.core.IClasspathEntry[], org.eclipse.core.runtime.IProgressMonitor)"><b>IJavaProject.html.setRawClasspath</b></a>
     (the delta indicates that package fragment roots have been <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#F_ADDED_TO_CLASSPATH">added to the classpath</a>, 
     <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#F_REMOVED_FROM_CLASSPATH">removed from the classpath</a>, or
     <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#F_CLASSPATH_REORDER">reordered on the classpath</a>)</li>
<li>Modifying a classpath variable value, e.g. <a href="../reference/api/org/eclipse/jdt/core/JavaCore.html#setClasspathVariable(java.lang.String, org.eclipse.core.runtime.IPath)"><b>JavaCore.html.setClasspathVariable</b></a></li>
<li>Changing the source attachment of a .jar file, e.g. <a href="../reference/api/org/eclipse/jdt/core/IPackageFragmentRoot.html#attachSource(org.eclipse.core.runtime.IPath, org.eclipse.core.runtime.IPath, org.eclipse.core.runtime.IProgressMonitor)"><b>JIPackageFragmentRoot.html.attachSource</b></a>
     (the delta indicates that the source was <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#F_SOURCEDETACHED">detached</a>
     then <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#F_SOURCEATTACHED">attached</a>)</li>
<li>Reconciling a working copy with its buffer, e.g. <a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#reconcile()"><b>IWorkingCopy.reconcile</b></a></li>
<li>Modifying an <a HREF="../../org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IFile.html"><b>IFile</b></a> that ends with ".java" and that is on the
      project's classpath, e.g. using <b>IFile.setContents</b> (the delta indicates that a compilation unit was changed, but 
      <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#F_FINE_GRAINED">no finer-grained information</a>
      is provided as this was not done through a Java Model operation)
</ul></P>
<P>
As for 
<a HREF="../../org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceDelta.html"><b>IResourceDelta</b></a> 
the Java element deltas can be batched using an 
<a HREF="../../org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspaceRunnable.html"><b>IWorkspaceRunnable</b></a>. 
The deltas resulting from several Java Model operations that are run inside a <b>IWorkspaceRunnable</b> are merged and reported at once.
</P>

<P>&nbsp;<a href="../hglegal2002.htm"><img src="../ngibmcpy2002.gif" alt="Copyright IBM Corporation and others 2000, 2002. All Rights Reserved." border="0"></a>
</P>
</BODY>
</HTML>
